<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Wheel of Standup - Smaller</title>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
 body {
   font-family: 'Nunito', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
   text-align: center;
   background-color: #f4f7f6; /* Soft off-white from index.html */
   color: #5d5d5d; /* Dark grey text from index.html */
   margin: 0;
   padding: 20px;
   display: flex;
   flex-direction: column;
   align-items: center;
   min-height: calc(100vh - 60px); /* Account for padding */
 }

 h1 {
   font-size: 2.6em;
   margin: 0 0 25px 0;
   color: #3498db; /* Friendly blue from index.html */
   font-weight: 700;
 }

 #settingsToggleBtn {
   position: absolute;
   top: 20px;
   right: 20px;
   padding: 10px 18px;
   font-size: 1em;
   background-color: #3498db; /* Friendly blue */
   color: #ffffff;
   border: none;
   border-radius: 8px;
   cursor: pointer;
   transition: background-color 0.3s ease;
   font-weight: 600;
 }
 #settingsToggleBtn:hover {
   background-color: #2980b9; /* Darker blue */
 }

 #config-area {
   position: absolute;
   top: 75px; /* Adjusted to be below new button size */
   right: 20px;
   background-color: #ffffff; /* Clean white from index.html */
   padding: 25px 30px;
   border-radius: 15px; /* Softer radius from index.html */
   box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08); /* Softer shadow from index.html */
   border: 1px solid #e0e0e0; /* Light border from index.html */
   max-width: 450px;
   z-index: 20;
   text-align: left;
 }

 #config-area label {
   display: block;
   margin-bottom: 8px;
   font-size: 1em;
   color: #7f8c8d; /* Muted grey from index.html */
   font-weight: 600;
 }

 #namesInput {
   width: 95%;
   min-height: 60px;
   padding: 10px;
   border-radius: 8px;
   border: 1px solid #ccc; /* Slightly darker than #e0e0e0 for inputs */
   background-color: #f9f9f9; /* Very light grey for inputs */
   color: #5d5d5d; /* Dark grey text */
   font-family: 'Nunito', sans-serif;
   font-size: 0.95em;
 }

 .config-hidden {
   display: none;
 }

 #wheel-container {
   position: relative;
   width: 425px; /* Keep this size for the wheel */
   margin: 20px auto; /* Add some margin */
 }

 canvas {
   border: 5px solid #e0e0e0; /* Consistent light border */
   border-radius: 50%;
   background-color: #ffffff; /* White background for the wheel drawing area */
   display: block;
   margin: 0 auto;
   /* width and height attributes on canvas tag will define drawing surface size */
 }

 #spinBtn, #updateNamesBtn {
   margin-top: 20px;
   padding: 12px 28px;
   font-size: 1.2em;
   font-weight: 700;
   background-color: #3498db; /* Friendly blue */
   color: #ffffff;
   border: none;
   border-radius: 8px;
   cursor: pointer;
   transition: background-color 0.3s ease;
 }
 #updateNamesBtn {
   background-color: #e67e22; /* A complementary orange for update, or use #2980b9 */
   margin-left: 10px;
 }
 #spinBtn:hover, #updateNamesBtn:hover {
   background-color: #2980b9; /* Darker blue for spin */
 }
 #updateNamesBtn:hover {
   background-color: #d35400; /* Darker orange for update */
 }

 #winner {
   font-size: 1.6em;
   margin-top: 25px;
   color: #2980b9; /* Darker blue for emphasis */
   min-height: 1.5em;
   font-weight: 600;
 }

 #indicator {
   position: absolute;
   top: -12px;
   left: 50%;
   transform: translateX(-50%) rotate(57deg);
   width: 0;
   height: 0;
   border-left: 14px solid transparent;
   border-right: 14px solid transparent;
   border-bottom: 22px solid #e74c3c; /* A vibrant red, or use #3498db */
   z-index: 10;
   filter: drop-shadow(0 1px 2px rgba(0,0,0,0.7));
 }
</style>
</head>
<body>
<h1>üéØ Wheel of Standup</h1>

<button id="settingsToggleBtn">‚öôÔ∏è Show Settings</button>
<div id="config-area" class="config-hidden">
  <label for="namesInput">Enter names (one per line or comma-separated):</label>
  <textarea id="namesInput" rows="4"></textarea>
  <button id="updateNamesBtn">Update List</button>
</div>

<div id="wheel-container">
 <div id="indicator"></div>
 <canvas id="wheel" width="425" height="425"></canvas> <!-- Match CSS size -->
</div>

<button id="spinBtn">üé≤ SPIN!</button>
<div id="winner"></div>

<script>
 const DEFAULT_NAMES = ['Kate', 'Andre', 'Juan', 'Dmytro', 'Vetura', 'Zachary', 'Lindsay'];
 let originalNames = [...DEFAULT_NAMES];
 let remaining = [...originalNames];

 const canvas = document.getElementById("wheel");
 const ctx = canvas.getContext("2d");
 const spinBtn = document.getElementById("spinBtn");
 const winnerDiv = document.getElementById("winner");
 const radius = canvas.width / 2;
 const namesInput = document.getElementById("namesInput");
 const updateNamesBtn = document.getElementById("updateNamesBtn");
 const settingsToggleBtn = document.getElementById("settingsToggleBtn");
 const configArea = document.getElementById("config-area");

 const LOCAL_STORAGE_KEY = 'namesList';

 let isSpinning = false;
 let lastWinnerIndex = null;

 function loadNamesFromStorage() {
   const storedNamesJson = localStorage.getItem(LOCAL_STORAGE_KEY);
   if (storedNamesJson) {
     try {
       const storedNames = JSON.parse(storedNamesJson);
       if (Array.isArray(storedNames) && storedNames.length > 0) {
         originalNames = [...storedNames];
         namesInput.value = storedNames.join('\n');
       } else {
         namesInput.value = DEFAULT_NAMES.join('\n'); // Fallback if stored data is invalid
       }
     } catch (e) {
       console.error("Error parsing names from localStorage:", e);
       originalNames = [...DEFAULT_NAMES]; // Fallback on error
       namesInput.value = DEFAULT_NAMES.join('\n');
     }
   } else {
     originalNames = [...DEFAULT_NAMES];
     namesInput.value = DEFAULT_NAMES.join('\n');
   }
   remaining = [...originalNames];
 }

 function saveNamesToStorage() {
   localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(originalNames));
 }
 function updateNamesFromInput() {
   const inputText = namesInput.value.trim();
   if (!inputText) {
     alert("Please enter at least one name.");
     return;
   }
   // Split by newline or comma, then trim whitespace and filter out empty strings
   const newNames = inputText.split(/[\n,]+/).map(name => name.trim()).filter(name => name.length > 0);

   if (newNames.length === 0) {
     alert("No valid names found. Please check your input.");
     return;
   }

   originalNames = [...newNames];
   remaining = [...originalNames];
   lastWinnerIndex = null;
   isSpinning = false; // Stop any current spin
   winnerDiv.innerText = "";
   saveNamesToStorage(); // Save the new names
   drawWheel(remaining, 0);
   // Optionally hide config after update for cleaner UX
   // toggleConfigArea(false);
 }

 function drawWheel(names, rotationAngle = 0) {
   const angleStep = (2 * Math.PI) / names.length;
   ctx.clearRect(0, 0, canvas.width, canvas.height);

   ctx.save();
   ctx.translate(radius, radius);
   ctx.rotate(rotationAngle);
   ctx.translate(-radius, -radius);

   names.forEach((name, i) => {
     const angle = i * angleStep;
     ctx.beginPath();
     ctx.moveTo(radius, radius);
     ctx.arc(radius, radius, radius, angle, angle + angleStep);
     ctx.fillStyle = `hsl(${(i * 360) / names.length}, 80%, 60%)`;
     ctx.fill();     

     // Draw text in the middle of each slice
     ctx.save();
     ctx.translate(radius, radius);
     ctx.rotate(angle + angleStep / 2);
     ctx.textAlign = "right";
     ctx.fillStyle = "#333333"; // Dark grey for better readability on lighter slices
     ctx.font = "bold 16px Arial";
     ctx.fillText(name, radius - 15, 6);
     ctx.restore();
   });

   ctx.restore();
 }

 function spinWheel() {
   if (isSpinning) return;

   // If a winner was just selected, clicking spin again will remove them and spin for the rest
   if (lastWinnerIndex !== null) {
     remaining.splice(lastWinnerIndex, 1);
     lastWinnerIndex = null;
     winnerDiv.innerText = "";
     drawWheel(remaining, 0);
     if (remaining.length === 0) {
       // All names from the current list have been picked
       winnerDiv.innerText = "‚úÖ All done! Everyone has spoken.";
       remaining = [...originalNames]
       return;
     }
   }

   if (remaining.length === 0) {
     winnerDiv.innerText = "‚úÖ All done! Update the list or spin again to restart.";
     remaining = [...originalNames]; // Reset for next round if they spin again without updating
     return;
   }

   isSpinning = true;

   const angleStep = (2 * Math.PI) / remaining.length;
   const selectedIndex = Math.floor(Math.random() * remaining.length);
   const selectedName = remaining[selectedIndex];

   // Calculate target rotation to align selected slice center with pointer at top (-90 degrees = 3pi/2 radians)
   const fullSpins = 4;
   const targetRotation = (fullSpins * 2 * Math.PI) + (3 * Math.PI / 2) - (selectedIndex * angleStep + angleStep / 2);

   let currentRotation = 0;

   function animate() {
     const progress = currentRotation / targetRotation;
     const easeOutSpeed = Math.max(0.01, (1 - progress) * 0.7);
     currentRotation += easeOutSpeed;

     drawWheel(remaining, currentRotation);

     if (currentRotation < targetRotation) {
       requestAnimationFrame(animate);
     } else {
       lastWinnerIndex = selectedIndex;
       winnerDiv.innerHTML = `üéâ <strong>${selectedName}</strong> is next to speak!`;
       isSpinning = false;
     }
   }

   animate();
 }

 function toggleConfigArea(show) {
   if (show === undefined) { // Toggle if no specific state is passed
     configArea.classList.toggle("config-hidden");
   } else if (show) {
     configArea.classList.remove("config-hidden");
   } else {
     configArea.classList.add("config-hidden");
   }
   settingsToggleBtn.textContent = configArea.classList.contains("config-hidden") ? "‚öôÔ∏è Show Settings" : "‚öôÔ∏è Hide Settings";
 }

 spinBtn.addEventListener("click", spinWheel);
 updateNamesBtn.addEventListener("click", updateNamesFromInput);
 settingsToggleBtn.addEventListener("click", () => toggleConfigArea());

 // Initial setup
 loadNamesFromStorage(); // Load names first
 drawWheel(remaining, 0);
 // Ensure config is hidden by default (CSS class handles this, but explicit call is fine)
 toggleConfigArea(false);

</script>

</body>
</html>
