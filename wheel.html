<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Wheel of Standup - Smaller</title>
<style>
 body {
   font-family: Arial, sans-serif;
   text-align: center;
   background: #222;
   color: #fff;
   margin: 0;
   padding: 20px;
 }
 #settingsToggleBtn {
   position: absolute;
   top: 20px;
   right: 20px;
   padding: 8px 15px;
   font-size: 0.9em;
   background: #555;
   color: white;
   border: none;
   border-radius: 5px;
   cursor: pointer;
   /* margin-bottom: 15px; Removed as it's now absolutely positioned */
   transition: background 0.3s;
 }
 #settingsToggleBtn:hover {
   background: #666;
 }
 #config-area {
   position: absolute; /* Position it relative to the body */
   top: 60px;      /* Below the settings button (adjust as needed) */
   right: 20px;     /* Align with the settings button's right edge */
   background: #333;
   padding: 15px;
   border-radius: 8px;
   max-width: 450px;
   /* margin-top: 30px; Removed as top positioning is used */
   /* margin-left: auto; Removed for absolute positioning */
   /* margin-right: auto; Removed for absolute positioning */
   z-index: 20; /* Ensure it's above the wheel if they overlap */
 }
 #config-area label {
   display: block;
   margin-bottom: 8px;
   font-size: 0.9em;
   color: #ccc;
 }
 #namesInput {
   width: 95%;
   min-height: 60px;
   padding: 8px;
   border-radius: 4px;
   border: 1px solid #555;
   background: #2a2a2a;
   color: #fff;
 }
 .config-hidden {
   display: none;
 }

 #wheel-container {
   position: relative;
   width: 425px;
   margin: 0 auto;
 }
 canvas {
   border: 4px solid #444;
   border-radius: 50%;
   background: #111;
   display: block;
   margin: 0 auto;
   width: 425px;
   height: 425px;
 }
 #spinBtn, #updateNamesBtn {
   margin-top: 20px;
   padding: 10px 24px;
   font-size: 1.1em;
   background: #00c853;
   color: white;
   border: none;
   border-radius: 8px;
   cursor: pointer;
   transition: background 0.3s;
 }
 #updateNamesBtn {
   background: #f0ad4e; /* Orange for update */
   margin-left: 10px;
 }
 #spinBtn:hover, #updateNamesBtn:hover {
   background: #00b34e;
 }
 #winner {
   font-size: 1.3em;
   margin-top: 25px;
   color: #ffeb3b;
   min-height: 1.5em;
 }
 #indicator {
   position: absolute;
   top: -12px;
   left: 50%;
   transform: translateX(-50%) rotate(57deg);
   width: 0;
   height: 0;
   border-left: 14px solid transparent;
   border-right: 14px solid transparent;
   border-bottom: 22px solid red;
   z-index: 10;
   filter: drop-shadow(0 1px 2px rgba(0,0,0,0.7));
 }
</style>
</head>
<body>

<h1>üéØ Wheel of Standup</h1>

<button id="settingsToggleBtn">‚öôÔ∏è Show Settings</button>
<div id="config-area" class="config-hidden">
  <label for="namesInput">Enter names (one per line or comma-separated):</label>
  <textarea id="namesInput" rows="4"></textarea>
  <button id="updateNamesBtn">Update List</button>
</div>

<div id="wheel-container">
 <div id="indicator"></div>
 <canvas id="wheel" width="350" height="350"></canvas>
</div>

<button id="spinBtn">üé≤ SPIN!</button>
<div id="winner"></div>

<script>
 const DEFAULT_NAMES = ['Kate', 'Andre', 'Juan', 'Dmytro', 'Vetura', 'Zachary', 'Lindsay'];
 let originalNames = [...DEFAULT_NAMES];
 let remaining = [...originalNames];

 const canvas = document.getElementById("wheel");
 const ctx = canvas.getContext("2d");
 const spinBtn = document.getElementById("spinBtn");
 const winnerDiv = document.getElementById("winner");
 const radius = canvas.width / 2;
 const namesInput = document.getElementById("namesInput");
 const updateNamesBtn = document.getElementById("updateNamesBtn");
 const settingsToggleBtn = document.getElementById("settingsToggleBtn");
 const configArea = document.getElementById("config-area");

 const LOCAL_STORAGE_KEY = 'wheelOfStandupNames';

 let isSpinning = false;
 let lastWinnerIndex = null;

 function loadNamesFromStorage() {
   const storedNamesJson = localStorage.getItem(LOCAL_STORAGE_KEY);
   if (storedNamesJson) {
     try {
       const storedNames = JSON.parse(storedNamesJson);
       if (Array.isArray(storedNames) && storedNames.length > 0) {
         originalNames = [...storedNames];
         namesInput.value = storedNames.join('\n');
       } else {
         namesInput.value = DEFAULT_NAMES.join('\n'); // Fallback if stored data is invalid
       }
     } catch (e) {
       console.error("Error parsing names from localStorage:", e);
       originalNames = [...DEFAULT_NAMES]; // Fallback on error
       namesInput.value = DEFAULT_NAMES.join('\n');
     }
   } else {
     originalNames = [...DEFAULT_NAMES];
     namesInput.value = DEFAULT_NAMES.join('\n');
   }
   remaining = [...originalNames];
 }

 function saveNamesToStorage() {
   localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(originalNames));
 }
 function updateNamesFromInput() {
   const inputText = namesInput.value.trim();
   if (!inputText) {
     alert("Please enter at least one name.");
     return;
   }
   // Split by newline or comma, then trim whitespace and filter out empty strings
   const newNames = inputText.split(/[\n,]+/).map(name => name.trim()).filter(name => name.length > 0);

   if (newNames.length === 0) {
     alert("No valid names found. Please check your input.");
     return;
   }

   originalNames = [...newNames];
   remaining = [...originalNames];
   lastWinnerIndex = null;
   isSpinning = false; // Stop any current spin
   winnerDiv.innerText = "";
   saveNamesToStorage(); // Save the new names
   drawWheel(remaining, 0);
   // Optionally hide config after update for cleaner UX
   // toggleConfigArea(false);
 }

 function drawWheel(names, rotationAngle = 0) {
   const angleStep = (2 * Math.PI) / names.length;
   ctx.clearRect(0, 0, canvas.width, canvas.height);

   ctx.save();
   ctx.translate(radius, radius);
   ctx.rotate(rotationAngle);
   ctx.translate(-radius, -radius);

   names.forEach((name, i) => {
     const angle = i * angleStep;
     ctx.beginPath();
     ctx.moveTo(radius, radius);
     ctx.arc(radius, radius, radius, angle, angle + angleStep);
     ctx.fillStyle = `hsl(${(i * 360) / names.length}, 80%, 60%)`;
     ctx.fill();

     // Draw text in the middle of each slice
     ctx.save();
     ctx.translate(radius, radius);
     ctx.rotate(angle + angleStep / 2);
     ctx.textAlign = "right";
     ctx.fillStyle = "#000";
     ctx.font = "bold 16px Arial";
     ctx.fillText(name, radius - 15, 6);
     ctx.restore();
   });

   ctx.restore();
 }

 function spinWheel() {
   if (isSpinning) return;

   // If a winner was just selected, clicking spin again will remove them and spin for the rest
   if (lastWinnerIndex !== null) {
     remaining.splice(lastWinnerIndex, 1);
     lastWinnerIndex = null;
     winnerDiv.innerText = "";
     drawWheel(remaining, 0);
     if (remaining.length === 0) {
       // All names from the current list have been picked
       winnerDiv.innerText = "‚úÖ All done! Everyone has spoken.";
       remaining = [...originalNames]
       return;
     }
   }

   if (remaining.length === 0) {
     winnerDiv.innerText = "‚úÖ All done! Update the list or spin again to restart.";
     remaining = [...originalNames]; // Reset for next round if they spin again without updating
     return;
   }

   isSpinning = true;

   const angleStep = (2 * Math.PI) / remaining.length;
   const selectedIndex = Math.floor(Math.random() * remaining.length);
   const selectedName = remaining[selectedIndex];

   // Calculate target rotation to align selected slice center with pointer at top (-90 degrees = 3pi/2 radians)
   const fullSpins = 4;
   const targetRotation = (fullSpins * 2 * Math.PI) + (3 * Math.PI / 2) - (selectedIndex * angleStep + angleStep / 2);

   let currentRotation = 0;

   function animate() {
     const progress = currentRotation / targetRotation;
     const easeOutSpeed = Math.max(0.01, (1 - progress) * 0.7);
     currentRotation += easeOutSpeed;

     drawWheel(remaining, currentRotation);

     if (currentRotation < targetRotation) {
       requestAnimationFrame(animate);
     } else {
       lastWinnerIndex = selectedIndex;
       winnerDiv.innerHTML = `üéâ <strong>${selectedName}</strong> is next to speak!`;
       isSpinning = false;
     }
   }

   animate();
 }

 function toggleConfigArea(show) {
   if (show === undefined) { // Toggle if no specific state is passed
     configArea.classList.toggle("config-hidden");
   } else if (show) {
     configArea.classList.remove("config-hidden");
   } else {
     configArea.classList.add("config-hidden");
   }
   settingsToggleBtn.textContent = configArea.classList.contains("config-hidden") ? "‚öôÔ∏è Show Settings" : "‚öôÔ∏è Hide Settings";
 }

 spinBtn.addEventListener("click", spinWheel);
 updateNamesBtn.addEventListener("click", updateNamesFromInput);
 settingsToggleBtn.addEventListener("click", () => toggleConfigArea());

 // Initial setup
 loadNamesFromStorage(); // Load names first
 drawWheel(remaining, 0);
 // Ensure config is hidden by default (CSS class handles this, but explicit call is fine)
 toggleConfigArea(false);

</script>

</body>
</html>
