<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Daily Pick Settings ‚Äì Players & Branding</title>
  <meta name="description" content="Manage shared player lists, colors, and emojis to keep every Daily Pick game on-brand across your team." />
  <meta name="keywords" content="daily pick settings, team roster, brand customization, stand-up tools" />

  <meta property="og:type" content="website">
  <meta property="og:url" content="https://dailypick.dev/apps/settings/">
  <meta property="og:title" content="Daily Pick Settings ‚Äì Players & Branding">
  <meta property="og:description" content="Manage shared player lists, colors, and emojis to keep every Daily Pick game on-brand across your team.">
  <meta property="og:image" content="https://dailypick.dev/assets/og-image-main.png">
  <meta property="og:image:alt" content="Settings panel for customizing Daily Pick players and branding">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://dailypick.dev/apps/settings/">
  <meta name="twitter:title" content="Daily Pick Settings ‚Äì Players & Branding">
  <meta name="twitter:description" content="Manage shared player lists, colors, and emojis to keep every Daily Pick game on-brand across your team.">
  <meta name="twitter:image" content="https://dailypick.dev/assets/og-image-main.png">
  <meta name="twitter:image:alt" content="Settings panel for customizing Daily Pick players and branding">

  <link rel="canonical" href="https://dailypick.dev/apps/settings/" />

  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="/assets/favicon/site.webmanifest">
  <link rel="shortcut icon" href="/assets/favicon/favicon.ico">
  <meta name="theme-color" content="#ffffff">

  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/theme.css">
  <link rel="stylesheet" href="/assets/css/glass.css">
  <link rel="stylesheet" href="style.css">
  <script src="/assets/js/brand-theme-engine.js" defer></script>
  <script src="/assets/js/brand-config.js" defer></script>
</head>

<body>
  {% include "bg-orbs.html" %}
  {% include "header.html" %}

  <main class="settings-page" aria-labelledby="settingsHeading">
    <section class="settings-hero glass-card">
      <div>
        <p class="eyebrow">Control center</p>
        <h1 id="settingsHeading">Settings &amp; Brand Studio</h1>
        <p>Update the shared player roster used across our games and tailor the Daily Pick look-and-feel to match your
          team. Changes save to your browser and apply instantly.</p>
      </div>
      <div class="hero-actions">
        <a class="btn-link" href="/apps/wheel/">Jump into a game ‚Üí</a>
        <button id="startTourBtn" type="button" class="btn-link ghost">Take the setup tour</button>
      </div>
    </section>

    <section class="settings-grid">
      <article class="settings-card glass-card" aria-labelledby="playersHeading">
        <div class="card-header">
          <h2 id="playersHeading">Player List</h2>
          <p>One list powers every picker. Add each teammate on its own line.</p>
        </div>
        <label for="playerNamesInput" class="sr-only">Player names</label>
        <textarea id="playerNamesInput" rows="8" spellcheck="false"></textarea>
        <p class="field-hint">Tip: paste from Slack or CSV, we clean it automatically.</p>
        <div class="button-row">
          <button id="savePlayersBtn" type="button">Save Players</button>
          <button id="resetPlayersBtn" type="button" class="ghost">Reset Names</button>
        </div>
        <p id="playersStatus" class="settings-status" aria-live="polite"></p>
      </article>

      <article class="settings-card glass-card" aria-labelledby="brandHeading">
        <div class="card-header">
          <h2 id="brandHeading">Brand Configuration</h2>
          <p>Use your own colors, emoji, and typography to make Daily Pick feel native to your team.</p>
        </div>

        <div class="brand-layout">
          <form id="brandForm" class="brand-form" novalidate>
            <section class="brand-subcard brand-subcard--identity" aria-labelledby="brandIdentityHeading">
              <div class="brand-subcard-header">
                <h3 id="brandIdentityHeading">Brand identity</h3>
                <p class="field-hint">Name, emoji, typography, and mark that appear across the interface.</p>
              </div>
              <div class="brand-grid brand-grid--identity">
                <label>
                  Brand name
                  <input type="text" id="brandNameInput" maxlength="32">
                </label>
                <label>
                  Brand emoji / mark
                  <input type="text" id="brandMarkInput" maxlength="4">
                </label>
                <label>
                  Font stack
                  <input type="text" id="fontFamilyInput" placeholder="'Nunito', system-ui, sans-serif">
                </label>
                <label>
                  Logo image URL (optional)
                  <input type="url" id="logoUrlInput" placeholder="https://example.com/logo.png">
                </label>
              </div>
            </section>

            <section class="brand-subcard brand-subcard--palette" aria-labelledby="brandPaletteHeading">
              <div class="brand-subcard-header">
                <h3 id="brandPaletteHeading">Color palette</h3>
                <p class="field-hint">Primary accents, surfaces, and typography colors for Daily Pick.</p>
              </div>
              <div class="brand-grid brand-grid--palette">
                <label>
                  Accent color
                  <input type="color" id="accentColorInput">
                </label>
                <label>
                  Accent (strong)
                  <input type="color" id="accentStrongInput">
                </label>
                <label>
                  Background color
                  <input type="color" id="backgroundColorInput">
                </label>
                <label>
                  Surface color
                  <input type="color" id="surfaceColorInput">
                </label>
                <label>
                  Text color
                  <input type="color" id="textColorInput">
                </label>
                <label>
                  Heading color
                  <input type="color" id="headingColorInput">
                </label>
                <label>
                  Subtle text color
                  <input type="color" id="subtleTextColorInput">
                </label>
                <label>
                  Border color
                  <input type="color" id="borderColorInput">
                </label>
              </div>
            </section>

            <section class="brand-subcard brand-subcard--themes" aria-labelledby="brandThemeHeading">
              <div class="brand-subcard-header">
                <h3 id="brandThemeHeading">Seasonal themes</h3>
                <p class="field-hint">Decide how holiday looks are activated across your brand.</p>
              </div>
              <fieldset class="theme-controls" aria-labelledby="themeControlsHeading">
                <legend id="themeControlsHeading">Seasonal themes</legend>
                <p class="field-hint">Holiday looks update automatically based on the Canadian calendar and include icons,
                  gradients, and palettes for major celebrations in Canada and the United States.</p>
                <label class="theme-toggle">
                  <input type="checkbox" id="seasonalThemesToggle" checked>
                  <span class="toggle-copy">
                    <span class="toggle-title">Enable seasonal themes</span>
                    <span class="toggle-description">Show holiday colors and emojis across the site when available.</span>
                  </span>
                </label>
                <p class="field-hint" id="seasonalThemesDisabledHint" hidden>Seasonal looks are paused. Turn them back on to access
                  holiday palettes and icons.</p>
                <label>
                  Theme mode
                  <select id="themeModeInput">
                    <option value="auto">Automatic (follow holiday calendar)</option>
                    <option value="manual">Manual selection</option>
                  </select>
                </label>
                <label class="manual-theme" data-theme-manual>
                  Active holiday theme
                  <select id="themeSelectInput" disabled>
                    <option value="default">Default Daily Pick</option>
                  </select>
                </label>
                <p class="field-hint" id="themeSelectionHint">Pick Manual to explore specific holidays or return to
                  Automatic for smart activation.</p>
              </fieldset>
              <div class="theme-summary" id="themeSummary" aria-live="polite"></div>
            </section>

            <div class="brand-form-actions">
              <div class="button-row">
                <button id="saveBrandBtn" type="button">Save Brand</button>
                <button id="resetBrandBtn" type="button" class="ghost">Reset Brand</button>
              </div>
              <p id="brandStatus" class="settings-status" aria-live="polite"></p>
            </div>
          </form>

          <aside class="brand-preview-column" aria-label="Brand preview">
            <div class="brand-preview" aria-live="polite">
              <div class="preview-header">
                <span class="preview-mark" aria-hidden="true">üéØ</span>
                <span class="preview-name">Daily Pick</span>
              </div>
              <div class="preview-theme" data-theme-active="false">
                <span class="preview-theme-icon" aria-hidden="true">üéÑ</span>
                <div class="preview-theme-copy">
                  <span class="preview-theme-name">Seasonal theme</span>
                  <span class="preview-theme-dates">Dec 1 ‚Äì Jan 5</span>
                </div>
              </div>
              <p>Buttons, headers, accents, and seasonal artwork update instantly as themes change.</p>
              <button type="button" disabled>Sample Button</button>
            </div>
          </aside>
        </div>
      </article>
    </section>

    <section class="settings-card glass-card integrations-panel" aria-labelledby="integrationsHeading">
        <div class="card-header">
          <h2 id="integrationsHeading">Third-Party Integrations</h2>
          <p>Connect Daily Pick to your delivery tools to sync boards and participants automatically.</p>
        </div>

        <div class="integration-overview">
          <p class="integration-intro">Connections save to the Daily Pick Worker so you can safely reuse them from any device. Tokens are masked after you save them.</p>
          <ul class="integration-highlights">
            <li><span>üîí</span> Secure tokens live on the Worker, never in the browser.</li>
            <li><span>üë•</span> Import players or keep their current work as a snapshot.</li>
            <li><span>‚ö°</span> Test a connection to preview teammates before saving.</li>
            <li><span>üí¨</span> Slack slash command runs rituals directly inside your workspace.</li>
          </ul>
        </div>

        <div class="integration-layout">
          <aside class="integration-list" role="tablist" aria-label="Choose an integration">
            <button type="button" class="integration-list__button is-active" role="tab" aria-selected="true" aria-controls="integration-panel-jira" data-integration-target="jira">
              <span class="integration-list__icon">üóÇÔ∏è</span>
              <span class="integration-list__copy">
                <strong>Jira</strong>
                <small>Boards & assignments</small>
              </span>
            </button>
            <button type="button" class="integration-list__button" role="tab" aria-selected="false" aria-controls="integration-panel-trello" data-integration-target="trello">
              <span class="integration-list__icon">üóíÔ∏è</span>
              <span class="integration-list__copy">
                <strong>Trello</strong>
                <small>Boards & cards</small>
              </span>
            </button>
            <button type="button" class="integration-list__button" role="tab" aria-selected="false" aria-controls="integration-panel-github" data-integration-target="github">
              <span class="integration-list__icon">üêô</span>
              <span class="integration-list__copy">
                <strong>GitHub</strong>
                <small>Repos & issues</small>
              </span>
            </button>
            <button type="button" class="integration-list__button" role="tab" aria-selected="false" aria-controls="integration-panel-slack" data-integration-target="slack">
              <span class="integration-list__icon">üí¨</span>
              <span class="integration-list__copy">
                <strong>Slack</strong>
                <small>Slash command</small>
              </span>
            </button>
          </aside>

          <div class="integration-panels">
          <section class="integration-card is-active" data-service="jira" aria-labelledby="integration-jira-heading" id="integration-panel-jira">
            <header class="integration-card-header">
              <div class="integration-icon" aria-hidden="true">üóÇÔ∏è</div>
              <div>
                <h3 id="integration-jira-heading">Jira</h3>
                <p>Import Jira teammates and their active work.</p>
              </div>
            </header>
            <label class="integration-toggle">
              <input type="checkbox" class="integration-enabled">
              <span>Enable connection</span>
            </label>
            <label>
              Jira site URL
              <input type="url" class="integration-field" data-field="siteUrl" placeholder="https://yourteam.atlassian.net">
            </label>
            <label>
              Project key
              <input type="text" class="integration-resource" placeholder="e.g. DP">
            </label>
            <label>
              Account email
              <input type="email" class="integration-field" data-field="email" placeholder="you@company.com">
            </label>
            <label>
              API token
              <input type="password" class="integration-token" placeholder="Paste a Jira API token">
            </label>
            <div class="integration-options">
              <label class="integration-option">
                <input type="checkbox" class="integration-include-assignments">
                <span class="integration-option__content">
                  <strong>Fetch assigned work preview</strong>
                  <small>Allow Daily Pick to load the current Jira issues for each teammate when you test the connection.</small>
                </span>
              </label>
            </div>
            <p class="integration-token-preview" aria-live="polite"></p>
            <p class="integration-status" aria-live="polite"></p>
            <div class="integration-results" hidden>
              <div class="integration-preview" aria-live="polite">
                <div class="integration-preview-section">
                  <h4>Players detected</h4>
                  <p class="integration-preview-players"></p>
                </div>
                <div class="integration-preview-section">
                  <h4>Assigned work</h4>
                  <div class="integration-preview-assignments"></div>
                </div>
              </div>
              <div class="integration-actions">
                <button type="button" class="integration-action integration-action-update">Update Player List</button>
                <button type="button" class="integration-action integration-action-save ghost">Save assigned work snapshot</button>
              </div>
            </div>
            <div class="button-row">
              <button type="button" class="integration-save">Save Connection</button>
              <button type="button" class="ghost integration-test">Test Connection</button>
              <button type="button" class="ghost integration-disconnect">Disconnect</button>
            </div>
          </section>

          <section class="integration-card" data-service="trello" aria-labelledby="integration-trello-heading" id="integration-panel-trello">
            <header class="integration-card-header">
              <div class="integration-icon" aria-hidden="true">üóíÔ∏è</div>
              <div>
                <h3 id="integration-trello-heading">Trello</h3>
                <p>Pull Trello board members and their cards.</p>
              </div>
            </header>
            <label class="integration-toggle">
              <input type="checkbox" class="integration-enabled">
              <span>Enable connection</span>
            </label>
            <label>
              Board or list URL
              <input type="url" class="integration-resource" placeholder="https://trello.com/b/...">
            </label>
            <label>
              API key
              <input type="text" class="integration-field" data-field="apiKey" placeholder="Trello API key">
            </label>
            <label>
              API token
              <input type="password" class="integration-token" placeholder="Paste a Trello API token">
            </label>
            <p class="integration-hint">
              Need credentials? Copy the 32-character API key from
              <a href="https://trello.com/app-key" target="_blank" rel="noopener">trello.com/app-key</a>,
              then generate a read token for your account and paste it here. This is different from the API secret.
              <button type="button" class="integration-hint-link trello-token-helper">Open token generator</button>
            </p>
            <div class="integration-options">
              <label class="integration-option">
                <input type="checkbox" class="integration-include-assignments">
                <span class="integration-option__content">
                  <strong>Fetch assigned work preview</strong>
                  <small>Pull card assignees and titles from this Trello board so the stand-up dock can show them.</small>
                </span>
              </label>
            </div>
            <p class="integration-token-preview" aria-live="polite"></p>
            <p class="integration-status" aria-live="polite"></p>
            <div class="integration-results" hidden>
              <div class="integration-preview" aria-live="polite">
                <div class="integration-preview-section">
                  <h4>Players detected</h4>
                  <p class="integration-preview-players"></p>
                </div>
                <div class="integration-preview-section">
                  <h4>Assigned work</h4>
                  <div class="integration-preview-assignments"></div>
                </div>
              </div>
              <div class="integration-actions">
                <button type="button" class="integration-action integration-action-update">Update Player List</button>
                <button type="button" class="integration-action integration-action-save ghost">Save assigned work snapshot</button>
              </div>
            </div>
            <div class="button-row">
              <button type="button" class="integration-save">Save Connection</button>
              <button type="button" class="ghost integration-test">Test Connection</button>
              <button type="button" class="ghost integration-disconnect">Disconnect</button>
            </div>
          </section>

          <section class="integration-card" data-service="github" aria-labelledby="integration-github-heading" id="integration-panel-github">
            <header class="integration-card-header">
              <div class="integration-icon" aria-hidden="true">üêô</div>
              <div>
                <h3 id="integration-github-heading">GitHub</h3>
                <p>Bring in GitHub collaborators and their open issues.</p>
              </div>
            </header>
            <label class="integration-toggle">
              <input type="checkbox" class="integration-enabled">
              <span>Enable connection</span>
            </label>
            <label>
              Repository full name
              <input type="text" class="integration-resource" placeholder="owner/repository">
            </label>
            <label>
              Personal access token
              <input type="password" class="integration-token" placeholder="Paste a GitHub token">
            </label>
            <div class="integration-options">
              <label class="integration-option">
                <input type="checkbox" class="integration-include-assignments">
                <span class="integration-option__content">
                  <strong>Fetch assigned work preview</strong>
                  <small>Let Daily Pick read open GitHub issues for collaborators when you run a test.</small>
                </span>
              </label>
            </div>
            <p class="integration-token-preview" aria-live="polite"></p>
            <p class="integration-status" aria-live="polite"></p>
            <div class="integration-results" hidden>
              <div class="integration-preview" aria-live="polite">
                <div class="integration-preview-section">
                  <h4>Players detected</h4>
                  <p class="integration-preview-players"></p>
                </div>
                <div class="integration-preview-section">
                  <h4>Assigned work</h4>
                  <div class="integration-preview-assignments"></div>
                </div>
              </div>
              <div class="integration-actions">
                <button type="button" class="integration-action integration-action-update">Update Player List</button>
                <button type="button" class="integration-action integration-action-save ghost">Save assigned work snapshot</button>
              </div>
            </div>
            <div class="button-row">
              <button type="button" class="integration-save">Save Connection</button>
              <button type="button" class="ghost integration-test">Test Connection</button>
              <button type="button" class="ghost integration-disconnect">Disconnect</button>
            </div>
          </section>
          <section class="integration-card" data-service="slack" aria-labelledby="integration-slack-heading" id="integration-panel-slack">
            <header class="integration-card-header">
              <div class="integration-icon" aria-hidden="true">üí¨</div>
              <div>
                <h3 id="integration-slack-heading">Slack slash command</h3>
                <p>Let teams launch Daily Pick rituals from Slack.</p>
              </div>
            </header>
            <label class="integration-toggle">
              <input type="checkbox" class="integration-enabled">
              <span>Enable Slack slash command</span>
            </label>
            <label>
              Slash command
              <input type="text" class="integration-resource" data-field="command" placeholder="/dailypick">
            </label>
            <label>
              Signing secret
              <input type="password" class="integration-token" placeholder="Paste the Slack signing secret">
            </label>
            <p class="integration-hint">Set Slack‚Äôs Request URL to <code id="slackCommandUrl">https://dailypick.dev/api/slack/command?client_id=...</code> and use the same client_id from this page.</p>
            <p class="integration-token-preview" aria-live="polite"></p>
            <p class="integration-status" aria-live="polite"></p>
            <div class="button-row">
              <button type="button" class="integration-save">Save Connection</button>
              <button type="button" class="ghost integration-disconnect">Disconnect</button>
            </div>
          </section>
          </div>
        </div>

        <div class="integration-guide-links">
          <p><strong>Need a full walkthrough?</strong> Read the integration playbooks on our blog:</p>
          <ul>
            <li><a href="/blog/connect-jira-to-daily-pick/" target="_blank" rel="noopener">How to connect Jira to Daily Pick</a></li>
            <li><a href="/blog/connect-trello-to-daily-pick/" target="_blank" rel="noopener">How to connect Trello to Daily Pick</a></li>
            <li><a href="/blog/connect-github-to-daily-pick/" target="_blank" rel="noopener">How to connect GitHub to Daily Pick</a></li>
            <li><a href="/blog/supercharge-async-standups-with-slack-and-daily-pick/" target="_blank" rel="noopener">How to run Daily Pick from Slack</a></li>
          </ul>
        </div>
      </section>

    <section class="settings-card glass-card tips">
      <h2>How it works</h2>
      <ul>
        <li>Settings are stored locally in your browser via <code>localStorage</code>.</li>
        <li>Every game loads the Players List before a match and applies your Brand
            Configuration on page load.</li>
        <li>Need to sync with teammates? Share your list via chat, then paste it here.</li>
      </ul>
    </section>
  </main>

  {% include "footer.html" %}

  <div id="setupTour" class="setup-tour" hidden aria-hidden="true">
    <div class="setup-tour__backdrop" data-tour-backdrop></div>
    <div class="setup-tour__focus" data-tour-focus></div>
    <div class="setup-tour__card" data-tour-card role="dialog" aria-modal="true" tabindex="-1">
      <p class="setup-tour__badge">
        Step <span data-tour-step-number>1</span> of <span data-tour-step-total>1</span>
      </p>
      <h3 class="setup-tour__title" data-tour-title></h3>
      <p class="setup-tour__description" data-tour-description></p>
      <div class="setup-tour__actions">
        <button id="tourPrevBtn" type="button" class="ghost">Back</button>
        <button id="tourNextBtn" type="button">Next</button>
        <button id="tourCloseBtn" type="button" class="ghost">Close</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const DEFAULT_NAMES = ['Kate', 'Andre', 'Juan', 'Dmytro', 'Vetura', 'Zachary', 'Lindsay'];
      const PLAYERS_KEY = 'namesList';
      const BRAND_CONFIG_KEY = 'brandConfig';
      const themeEngine = window.BrandThemeEngine;
      const FALLBACK_BRAND = {
        brandName: 'Daily Pick',
        brandMark: 'üéØ',
        accentColor: '#3498db',
        accentStrong: '#2980b9',
        backgroundColor: '#f4f7f6',
        surfaceColor: '#ffffff',
        textColor: '#34495e',
        headingColor: '#2d3e50',
        subtleTextColor: '#7f8c8d',
        borderColor: '#dde4eb',
        radius: '18px',
        shadow: '0 10px 30px rgba(0, 0, 0, 0.08)',
        fontFamily: "'Nunito', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
        logoUrl: '',
        themeIcon: '',
        themeBackground: 'none',
        themeAccentGlow: 'none',
        themeMode: 'auto',
        activeThemeId: null,
        holidayThemes: {},
        themeSchemaVersion: 1,
        seasonalThemesEnabled: true,
      };
      const DEFAULT_BRAND = themeEngine
        ? themeEngine.createDefaultBrandConfig()
        : { ...FALLBACK_BRAND };
      if (typeof DEFAULT_BRAND.seasonalThemesEnabled === 'undefined') {
        DEFAULT_BRAND.seasonalThemesEnabled = true;
      }

      const playerNamesInput = document.getElementById('playerNamesInput');
      const savePlayersBtn = document.getElementById('savePlayersBtn');
      const resetPlayersBtn = document.getElementById('resetPlayersBtn');
      const playersStatus = document.getElementById('playersStatus');

      const brandInputs = {
        brandName: document.getElementById('brandNameInput'),
        brandMark: document.getElementById('brandMarkInput'),
        accentColor: document.getElementById('accentColorInput'),
        accentStrong: document.getElementById('accentStrongInput'),
        backgroundColor: document.getElementById('backgroundColorInput'),
        surfaceColor: document.getElementById('surfaceColorInput'),
        textColor: document.getElementById('textColorInput'),
        headingColor: document.getElementById('headingColorInput'),
        subtleTextColor: document.getElementById('subtleTextColorInput'),
        borderColor: document.getElementById('borderColorInput'),
        fontFamily: document.getElementById('fontFamilyInput'),
        logoUrl: document.getElementById('logoUrlInput'),
      };
      const saveBrandBtn = document.getElementById('saveBrandBtn');
      const resetBrandBtn = document.getElementById('resetBrandBtn');
      const brandStatus = document.getElementById('brandStatus');
      const brandPreview = document.querySelector('.brand-preview');
      const previewName = brandPreview.querySelector('.preview-name');
      const previewMark = brandPreview.querySelector('.preview-mark');
      const previewButton = brandPreview.querySelector('button');
      const themeModeInput = document.getElementById('themeModeInput');
      const themeSelectInput = document.getElementById('themeSelectInput');
      const themeSummary = document.getElementById('themeSummary');
      const manualThemeControl = document.querySelector('[data-theme-manual]');
      const previewTheme = brandPreview.querySelector('.preview-theme');
      const previewThemeIcon = brandPreview.querySelector('.preview-theme-icon');
      const previewThemeName = brandPreview.querySelector('.preview-theme-name');
      const previewThemeDates = brandPreview.querySelector('.preview-theme-dates');
      const seasonalThemesToggle = document.getElementById('seasonalThemesToggle');
      const seasonalThemesDisabledHint = document.getElementById('seasonalThemesDisabledHint');

      let holidayThemes = generateHolidayThemes();
      if (!holidayThemes || !Object.keys(holidayThemes).length) {
        holidayThemes = DEFAULT_BRAND.holidayThemes || {};
      }
      DEFAULT_BRAND.holidayThemes = holidayThemes;
      populateThemeOptions(holidayThemes);
      setManualThemeVisibility(
        DEFAULT_BRAND.themeMode,
        DEFAULT_BRAND.seasonalThemesEnabled !== false,
      );
      function updateSlackCommandUrl(clientId) {
        const urlEl = document.getElementById('slackCommandUrl');
        if (!urlEl || !clientId) return;
        const origin = window.location.origin || 'https://dailypick.dev';
        const url = `${origin.replace(/\/$/, '')}/api/slack/command?client_id=${clientId}`;
        urlEl.textContent = url;
      }

      const integrationEndpoint = '/api/integrations/config';
      const integrationCards = Array.from(document.querySelectorAll('.integration-card'));
      const integrationNavButtons = Array.from(document.querySelectorAll('[data-integration-target]'));
      const ASSIGNMENTS_STORAGE_KEY = 'integrationAssignments';
      const ASSIGNMENT_ITEM_FIELDS = ['id', 'key', 'name', 'summary', 'status', 'url', 'number', 'title', 'state', 'listId'];
      const INTEGRATION_CLIENT_KEY = 'integrationClientId';
      const integrationResults = new Map();
      const integrationClientId = loadIntegrationClientId();
      updateSlackCommandUrl(integrationClientId);
      const startTourBtn = document.getElementById('startTourBtn');
      const tourOverlay = document.getElementById('setupTour');
      const tourFocus = tourOverlay?.querySelector('[data-tour-focus]');
      const tourCard = tourOverlay?.querySelector('[data-tour-card]');
      const tourTitle = tourOverlay?.querySelector('[data-tour-title]');
      const tourDescription = tourOverlay?.querySelector('[data-tour-description]');
      const tourNumber = tourOverlay?.querySelector('[data-tour-step-number]');
      const tourTotal = tourOverlay?.querySelector('[data-tour-step-total]');
      const tourPrevBtn = document.getElementById('tourPrevBtn');
      const tourNextBtn = document.getElementById('tourNextBtn');
      const tourCloseBtn = document.getElementById('tourCloseBtn');
      const TOUR_STEPS = [
        {
          title: 'Build your player list',
          description: 'List every teammate on its own line, save the roster, and reuse it across games without retyping.',
          target: '#playerNamesInput',
          focusPadding: 16,
        },
        {
          title: 'Tailor the brand studio',
          description: 'Pick your colors, fonts, emoji mark, and optional logo so Daily Pick matches your team.',
          target: '.brand-form',
          focusPadding: 18,
        },
        {
          title: 'Connect integrations',
          description: 'Enable Jira, Trello, GitHub, or Slack to import teammates and assignment previews with one test.',
          target: '.integration-layout',
          focusPadding: 18,
        },
        {
          title: 'Finish setup',
          description: 'Remember the quick tips, share the list with teammates, and jump into a game whenever you are ready.',
          target: '.tips',
          focusPadding: 14,
        },
      ];
      let currentTourStep = 0;
      let tourActive = false;
      let activeTourTarget = null;

      function generateHolidayThemes() {
        if (themeEngine && typeof themeEngine.buildHolidayThemes === 'function') {
          return themeEngine.buildHolidayThemes();
        }
        return DEFAULT_BRAND.holidayThemes || {};
      }

      function populateThemeOptions(themes = {}) {
        if (!themeSelectInput) return;
        themeSelectInput.innerHTML = '';
        const defaultOption = document.createElement('option');
        defaultOption.value = 'default';
        defaultOption.textContent = 'Default Daily Pick';
        themeSelectInput.appendChild(defaultOption);
        Object.values(themes).forEach((theme) => {
          const option = document.createElement('option');
          option.value = theme.id;
          const rangeLabel = theme.metadata?.rangeLabel ? ` ‚Äî ${theme.metadata.rangeLabel}` : '';
          option.textContent = `${theme.name}${rangeLabel}`;
          themeSelectInput.appendChild(option);
        });
      }

      function getTourTargetRect(step) {
        if (!step?.target) return null;
        const target = document.querySelector(step.target);
        return target ? target.getBoundingClientRect() : null;
      }

      function markTourTarget(target) {
        if (activeTourTarget && activeTourTarget !== target) {
          activeTourTarget.classList.remove('setup-tour__target');
        }
        activeTourTarget = target;
        if (activeTourTarget) {
          activeTourTarget.classList.add('setup-tour__target');
        }
      }

      function updateTourFocus(rect, padding = 12) {
        if (!tourFocus) return;
        if (!rect) {
          tourFocus.style.opacity = '0';
          tourFocus.style.width = '0';
          tourFocus.style.height = '0';
          return;
        }
        const pad = Number.isFinite(padding) ? padding : 12;
        const width = Math.max(rect.width + pad * 2, 40);
        const height = Math.max(rect.height + pad * 2, 40);
        tourFocus.style.top = `${Math.max(rect.top - pad, 8)}px`;
        tourFocus.style.left = `${Math.max(rect.left - pad, 8)}px`;
        tourFocus.style.width = `${width}px`;
        tourFocus.style.height = `${height}px`;
        tourFocus.style.opacity = '1';
      }

      function positionTourCard(rect, padding = 12) {
        if (!tourCard) return;
        const { width: cardWidth, height: cardHeight } = tourCard.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        let top = viewportHeight - cardHeight - 24;
        let left = (viewportWidth - cardWidth) / 2;
        if (rect) {
          const pad = Number.isFinite(padding) ? padding : 12;
          const belowTop = rect.bottom + pad;
          const aboveTop = rect.top - cardHeight - pad;
          if (belowTop + cardHeight + 12 <= viewportHeight) {
            top = belowTop;
          } else if (aboveTop >= 12) {
            top = aboveTop;
          } else {
            top = (viewportHeight - cardHeight) / 2;
          }
          const potentialLeft = rect.left;
          left = Math.max(12, Math.min(potentialLeft, viewportWidth - cardWidth - 12));
        }
        top = Math.max(12, Math.min(top, viewportHeight - cardHeight - 12));
        left = Math.max(12, Math.min(left, viewportWidth - cardWidth - 12));
        tourCard.style.top = `${top}px`;
        tourCard.style.left = `${left}px`;
      }

      function renderTourStep() {
        if (!tourOverlay || !tourCard || !TOUR_STEPS.length) return;
        const step = TOUR_STEPS[currentTourStep];
        if (!step) return;
        tourTitle && (tourTitle.textContent = step.title);
        tourDescription && (tourDescription.textContent = step.description);
        tourNumber && (tourNumber.textContent = `${currentTourStep + 1}`);
        tourTotal && (tourTotal.textContent = `${TOUR_STEPS.length}`);
        if (tourPrevBtn) {
          tourPrevBtn.disabled = currentTourStep === 0;
        }
        if (tourNextBtn) {
          tourNextBtn.textContent = currentTourStep === TOUR_STEPS.length - 1 ? 'Finish tour' : 'Next';
        }
        const stepTargetElement = step?.target ? document.querySelector(step.target) : null;
        if (stepTargetElement) {
          stepTargetElement.scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'auto' });
        }
        markTourTarget(stepTargetElement);
        requestAnimationFrame(() => {
          const rect = stepTargetElement ? stepTargetElement.getBoundingClientRect() : getTourTargetRect(step);
          updateTourFocus(rect, step.focusPadding);
          positionTourCard(rect, step.focusPadding);
        });
      }

      function goToTourStep(index) {
        if (!TOUR_STEPS.length) return;
        currentTourStep = Math.max(0, Math.min(index, TOUR_STEPS.length - 1));
        renderTourStep();
      }

      function refreshTourLayout() {
        if (!tourActive) return;
        const step = TOUR_STEPS[currentTourStep];
        const rect = getTourTargetRect(step);
        updateTourFocus(rect, step?.focusPadding);
        positionTourCard(rect, step?.focusPadding);
      }

      function openTour() {
        if (!tourOverlay || !TOUR_STEPS.length) return;
        tourActive = true;
        tourOverlay.removeAttribute('hidden');
        tourOverlay.setAttribute('aria-hidden', 'false');
        goToTourStep(0);
        tourCard?.focus();
      }

      function closeTour() {
        if (!tourOverlay) return;
        tourActive = false;
        tourOverlay.setAttribute('hidden', '');
        tourOverlay.setAttribute('aria-hidden', 'true');
        tourFocus && (tourFocus.style.opacity = '0');
        markTourTarget(null);
      }

      tourTotal && (tourTotal.textContent = `${TOUR_STEPS.length}`);
      function setManualThemeVisibility(mode, seasonalEnabled = true) {
        if (!manualThemeControl || !themeSelectInput) return;
        const allowSeasonal = Boolean(seasonalEnabled);
        const manual = allowSeasonal && mode === 'manual';
        manualThemeControl.classList.toggle('is-active', manual);
        manualThemeControl.classList.toggle('is-disabled', !allowSeasonal);
        themeSelectInput.disabled = !manual;
        if (themeModeInput) {
          themeModeInput.disabled = !allowSeasonal;
          const modeLabel = themeModeInput.closest('label');
          if (modeLabel) {
            modeLabel.classList.toggle('is-disabled', !allowSeasonal);
          }
        }
        if (seasonalThemesDisabledHint) {
          seasonalThemesDisabledHint.hidden = allowSeasonal;
        }
      }

      function showStatus(el, message) {
        if (!el) return;
        el.textContent = message;
        setTimeout(() => { el.textContent = ''; }, 4000);
      }

      function normalizeNamesInput(raw) {
        if (!raw) return [];
        return raw
          .split(/[\n,]+/)
          .map(name => name.trim())
          .filter(Boolean);
      }

      function dedupeNames(names = []) {
        const seen = new Set();
        const result = [];
        names.forEach((name) => {
          if (typeof name !== 'string') return;
          const trimmed = name.trim();
          if (!trimmed) return;
          const key = trimmed.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          result.push(trimmed);
        });
        return result;
      }

      function safeParseJson(raw, fallback) {
        if (!raw) return fallback;
        try {
          const parsed = JSON.parse(raw);
          return typeof parsed === 'object' && parsed !== null ? parsed : fallback;
        } catch {
          return fallback;
        }
      }

      function sanitizeAssignmentItem(item) {
        if (!item || typeof item !== 'object') return null;
        const sanitized = {};
        ASSIGNMENT_ITEM_FIELDS.forEach((field) => {
          if (item[field] == null) return;
          const value = String(item[field]).slice(0, 200);
          if (value) {
            sanitized[field] = value;
          }
        });
        return Object.keys(sanitized).length ? sanitized : null;
      }

      function createIntegrationClientId() {
        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
          return crypto.randomUUID();
        }
        const random = Math.random().toString(36).slice(2, 10);
        const timestamp = Date.now().toString(36);
        return `dp-${random}${timestamp}`;
      }

      function loadIntegrationClientId() {
        try {
          const existing = localStorage.getItem(INTEGRATION_CLIENT_KEY);
          if (existing && existing.trim().length >= 8) {
            return existing.trim();
          }
        } catch (error) {
          console.warn('Unable to read integration client id from storage', error);
        }
        const fresh = createIntegrationClientId();
        try {
          localStorage.setItem(INTEGRATION_CLIENT_KEY, fresh);
        } catch (error) {
          console.warn('Unable to persist integration client id', error);
        }
        return fresh;
      }

      function sanitizeAssignmentsPayload(assignments = []) {
        return assignments
          .filter((entry) => entry && typeof entry === 'object' && typeof entry.player === 'string')
          .map((entry) => {
            const player = entry.player.trim();
            if (!player) return null;
            const items = Array.isArray(entry.items) ? entry.items.slice(0, 25) : [];
            const sanitizedItems = items
              .map((item) => sanitizeAssignmentItem(item))
              .filter(Boolean);
            return {
              player,
              items: sanitizedItems,
            };
          })
          .filter(Boolean);
      }

      function loadAssignmentSnapshots() {
        return safeParseJson(localStorage.getItem(ASSIGNMENTS_STORAGE_KEY), {});
      }

      function persistAssignmentsSnapshot(service, data) {
        if (!service || !data) return false;
        const sanitizedAssignments = sanitizeAssignmentsPayload(data.assignments);
        const players = Array.isArray(data.players) ? dedupeNames(data.players) : [];

        if (!sanitizedAssignments.length) {
          return false;
        }

        const store = loadAssignmentSnapshots();
        store[service] = {
          service,
          fetchedAt: new Date().toISOString(),
          players,
          assignments: sanitizedAssignments,
        };
        try {
          localStorage.setItem(ASSIGNMENTS_STORAGE_KEY, JSON.stringify(store));
          return true;
        } catch (error) {
          console.warn('Unable to persist assignment snapshot', error);
          return false;
        }
      }

      function clearAssignmentSnapshot(service) {
        if (!service) return;
        const store = loadAssignmentSnapshots();
        if (!(service in store)) return;
        delete store[service];
        try {
          if (Object.keys(store).length) {
            localStorage.setItem(ASSIGNMENTS_STORAGE_KEY, JSON.stringify(store));
          } else {
            localStorage.removeItem(ASSIGNMENTS_STORAGE_KEY);
          }
        } catch (error) {
          console.warn('Unable to clear assignment snapshot', error);
        }
      }

      function formatServiceName(service) {
        switch (service) {
          case 'jira':
            return 'Jira';
          case 'trello':
            return 'Trello';
          case 'github':
            return 'GitHub';
          default:
            return 'Integration';
        }
      }

      function applyPlayersFromIntegration(service, players) {
        if (!Array.isArray(players) || !players.length || !playerNamesInput) {
          return false;
        }

        const existing = dedupeNames(normalizeNamesInput(playerNamesInput.value));
        const incoming = dedupeNames(players);
        if (!incoming.length) {
          return false;
        }

        const existingSet = new Set(existing.map((name) => name.toLowerCase()));
        const newNames = incoming.filter((name) => !existingSet.has(name.toLowerCase()));
        if (!newNames.length) {
          return false;
        }

        const merged = dedupeNames([...existing, ...newNames]);
        playerNamesInput.value = merged.join('\n');
        localStorage.setItem(PLAYERS_KEY, JSON.stringify(merged));
        showStatus(playersStatus, `Added ${newNames.length} player${newNames.length === 1 ? '' : 's'} from ${formatServiceName(service)}.`);
        return true;
      }

      function loadPlayers() {
        const stored = localStorage.getItem(PLAYERS_KEY);
        let names = DEFAULT_NAMES;
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed) && parsed.length) {
              names = parsed;
            }
          } catch {
            names = DEFAULT_NAMES;
          }
        }
        if (playerNamesInput) {
          playerNamesInput.value = names.join('\n');
        }
      }

      function savePlayers() {
        if (!playerNamesInput) return;
        const names = normalizeNamesInput(playerNamesInput.value);
        const toPersist = names.length ? names : DEFAULT_NAMES;
        playerNamesInput.value = toPersist.join('\n');
        localStorage.setItem(PLAYERS_KEY, JSON.stringify(toPersist));
        showStatus(playersStatus, `Saved ${toPersist.length} player${toPersist.length === 1 ? '' : 's'}.`);
      }

      function resetPlayers() {
        if (!playerNamesInput) return;
        localStorage.removeItem(PLAYERS_KEY);
        playerNamesInput.value = DEFAULT_NAMES.join('\n');
        showStatus(playersStatus, 'Reverted to default names.');
      }

      function safeParseBrandConfig(raw) {
        if (!raw) return null;
        try {
          const parsed = JSON.parse(raw);
          return typeof parsed === 'object' && parsed !== null ? parsed : null;
        } catch {
          return null;
        }
      }

      function loadBrand() {
        const stored = safeParseBrandConfig(localStorage.getItem(BRAND_CONFIG_KEY));
        holidayThemes = generateHolidayThemes();
        DEFAULT_BRAND.holidayThemes = holidayThemes;
        populateThemeOptions(holidayThemes);
        const composition = composeBrandConfig(stored || {});
        const data = composition.config;
        Object.entries(brandInputs).forEach(([key, input]) => {
          if (input) {
            input.value = data[key] ?? '';
          }
        });
        if (themeModeInput) {
          themeModeInput.value = data.themeMode || 'auto';
        }
        if (seasonalThemesToggle) {
          const enabled = data.seasonalThemesEnabled !== false;
          seasonalThemesToggle.checked = enabled;
        }
        if (themeSelectInput) {
          const manualValue = data.activeThemeId || 'default';
          const option = Array.from(themeSelectInput.options).find((opt) => opt.value === manualValue);
          themeSelectInput.value = option ? manualValue : 'default';
        }
        setManualThemeVisibility(
          data.themeMode,
          data.seasonalThemesEnabled !== false,
        );
        updatePreview(data);
      }

      function collectBrandForm(includeBlanks = false) {
        const data = {};
        Object.entries(brandInputs).forEach(([key, input]) => {
          if (!input) return;
          const value = input.value.trim();
          if (value || includeBlanks) {
            data[key] = value;
          }
        });
        const modeValue = themeModeInput ? themeModeInput.value : DEFAULT_BRAND.themeMode;
        if (modeValue || includeBlanks) {
          data.themeMode = modeValue || 'auto';
        }
        if (themeSelectInput) {
          const rawValue = themeSelectInput.value;
          const manualValue = rawValue && rawValue !== 'default' ? rawValue : null;
          if (modeValue === 'manual') {
            if (manualValue || includeBlanks) {
              data.activeThemeId = manualValue;
            }
          } else if (includeBlanks) {
            data.activeThemeId = null;
          }
        }
        if (seasonalThemesToggle) {
          data.seasonalThemesEnabled = seasonalThemesToggle.checked;
        } else if (includeBlanks) {
          data.seasonalThemesEnabled = true;
        }
        return data;
      }

      function composeBrandConfig(configOverride = {}) {
        const candidate = { ...DEFAULT_BRAND, ...configOverride, holidayThemes };
        if (themeEngine && typeof themeEngine.composeBrandStyles === 'function') {
          return themeEngine.composeBrandStyles(candidate);
        }
        return { config: candidate, styles: candidate, activeTheme: null };
      }

      function updateThemeSummary(config, activeTheme) {
        if (!themeSummary) return;
        if (config?.seasonalThemesEnabled === false) {
          themeSummary.textContent = 'Seasonal themes disabled ‚Äî Custom brand colors';
          return;
        }
        const modeLabel = config?.themeMode === 'manual' ? 'Manual mode' : 'Automatic mode';
        const name = activeTheme?.name || 'Default Daily Pick';
        const range = activeTheme?.metadata?.rangeLabel;
        const description = activeTheme?.metadata?.description;
        const segments = [modeLabel, name];
        if (range) {
          segments.push(range);
        }
        let summary = segments.join(' ¬∑ ');
        if (description) {
          summary += ` ‚Äî ${description}`;
        } else if (!activeTheme) {
          summary += ' ‚Äî Custom brand colors';
        }
        themeSummary.textContent = summary;
      }

      function updatePreview(configOverride) {
        const composition = composeBrandConfig(configOverride);
        const { styles, activeTheme, config } = composition;
        brandPreview.style.setProperty('--preview-accent', styles.accentColor);
        brandPreview.style.setProperty('--preview-surface', styles.surfaceColor);
        brandPreview.style.setProperty('--preview-text', styles.textColor);
        brandPreview.style.setProperty('--preview-heading', styles.headingColor);
        brandPreview.style.setProperty('--preview-border', styles.borderColor);
        brandPreview.style.setProperty('--preview-font', styles.fontFamily);
        const previewBackground = styles.themeBackground && styles.themeBackground !== 'none'
          ? styles.themeBackground
          : styles.surfaceColor;
        brandPreview.style.background = previewBackground;
        const basePreviewShadow = 'inset 0 0 0 1px rgba(255, 255, 255, 0.3)';
        brandPreview.style.boxShadow = styles.themeAccentGlow && styles.themeAccentGlow !== 'none'
          ? `${styles.themeAccentGlow}, ${basePreviewShadow}`
          : basePreviewShadow;
        previewName.textContent = styles.brandName;
        previewMark.textContent = styles.brandMark;
        previewButton.style.background = styles.accentColor;
        previewButton.style.borderColor = styles.accentStrong;

        const seasonalEnabled = config?.seasonalThemesEnabled !== false;
        const themeActive = seasonalEnabled && Boolean(activeTheme);
        previewTheme.dataset.themeActive = themeActive ? 'true' : 'false';
        previewTheme.dataset.seasonalEnabled = seasonalEnabled ? 'true' : 'false';
        if (!seasonalEnabled) {
          previewThemeIcon.textContent = styles.brandMark || 'üéØ';
          previewThemeName.textContent = 'Seasonal themes disabled';
          previewThemeDates.textContent = 'Using custom brand colors';
        } else if (themeActive) {
          previewThemeIcon.textContent = activeTheme.assets?.icon || styles.themeIcon || 'üéâ';
          previewThemeName.textContent = activeTheme.name;
          previewThemeDates.textContent = activeTheme.metadata?.rangeLabel || '';
        } else {
          previewThemeIcon.textContent = styles.themeIcon || '‚ú®';
          previewThemeName.textContent = 'Default Daily Pick';
          previewThemeDates.textContent = 'Always available';
        }

        updateThemeSummary(config, activeTheme);
        return composition;
      }

      function saveBrand() {
        const formData = collectBrandForm(true);
        holidayThemes = generateHolidayThemes();
        DEFAULT_BRAND.holidayThemes = holidayThemes;
        const merged = { ...DEFAULT_BRAND, ...formData, holidayThemes };
        const normalized = themeEngine && typeof themeEngine.upgradeBrandConfig === 'function'
          ? themeEngine.upgradeBrandConfig(merged)
          : merged;
        localStorage.setItem(BRAND_CONFIG_KEY, JSON.stringify(normalized));
        window.dispatchEvent(new CustomEvent('brandConfigUpdated', { detail: normalized }));
        updatePreview(normalized);
        showStatus(brandStatus, 'Brand updated.');
      }

      function resetBrand() {
        Object.entries(brandInputs).forEach(([key, input]) => {
          if (input) input.value = DEFAULT_BRAND[key] ?? '';
        });
        localStorage.removeItem(BRAND_CONFIG_KEY);
        if (themeModeInput) {
          themeModeInput.value = DEFAULT_BRAND.themeMode || 'auto';
        }
        if (seasonalThemesToggle) {
          seasonalThemesToggle.checked = DEFAULT_BRAND.seasonalThemesEnabled !== false;
        }
        if (themeSelectInput) {
          themeSelectInput.value = 'default';
        }
        setManualThemeVisibility(
          DEFAULT_BRAND.themeMode,
          DEFAULT_BRAND.seasonalThemesEnabled !== false,
        );
        holidayThemes = generateHolidayThemes();
        DEFAULT_BRAND.holidayThemes = holidayThemes;
        const normalized = themeEngine && typeof themeEngine.upgradeBrandConfig === 'function'
          ? themeEngine.upgradeBrandConfig(DEFAULT_BRAND)
          : { ...DEFAULT_BRAND };
        window.dispatchEvent(new CustomEvent('brandConfigUpdated', { detail: normalized }));
        updatePreview(normalized);
        showStatus(brandStatus, 'Brand reset to defaults.');
      }

      function setIntegrationStatus(card, message, tone = 'info') {
        const statusEl = card.querySelector('.integration-status');
        if (!statusEl) return;
        if (!message) {
          statusEl.textContent = '';
          delete statusEl.dataset.tone;
          return;
        }
        statusEl.textContent = message;
        statusEl.dataset.tone = tone;
        setTimeout(() => {
          if (statusEl.textContent === message) {
            statusEl.textContent = '';
            delete statusEl.dataset.tone;
          }
        }, 7000);
      }

      function setIntegrationBusy(card, busy) {
        card.classList.toggle('is-busy', busy);
        const buttons = card.querySelectorAll('.integration-save, .integration-disconnect, .integration-test, .integration-action');
        buttons.forEach(btn => {
          btn.disabled = busy;
        });
      }

      function setActiveIntegration(service) {
        if (!service || !integrationCards.length) return;
        integrationNavButtons.forEach((button) => {
          const targetMatch = button.dataset.integrationTarget === service;
          button.classList.toggle('is-active', targetMatch);
          button.setAttribute('aria-selected', targetMatch ? 'true' : 'false');
        });
        integrationCards.forEach((card) => {
          const isMatch = card.dataset.service === service;
          card.classList.toggle('is-active', isMatch);
          card.hidden = !isMatch;
          card.setAttribute('aria-hidden', isMatch ? 'false' : 'true');
        });
      }

      function openTrelloTokenGenerator(card) {
        if (!card) return;
        const apiKeyInput = card.querySelector('[data-field="apiKey"]');
        const apiKey = apiKeyInput?.value?.trim();
        if (!apiKey) {
          setIntegrationStatus(card, 'Enter your Trello API key before opening the token generator.', 'error');
          apiKeyInput?.focus();
          return;
        }
        const url = new URL('https://trello.com/1/authorize');
        url.searchParams.set('expiration', 'never');
        url.searchParams.set('scope', 'read');
        url.searchParams.set('response_type', 'token');
        url.searchParams.set('name', 'Daily Pick');
        url.searchParams.set('key', apiKey);
        window.open(url.toString(), '_blank', 'noopener');
      }

      function getIntegrationResultElements(card) {
        if (!card) return {};
        return {
          container: card.querySelector('.integration-results'),
          players: card.querySelector('.integration-preview-players'),
          assignments: card.querySelector('.integration-preview-assignments'),
          updateBtn: card.querySelector('.integration-action-update'),
          saveBtn: card.querySelector('.integration-action-save'),
        };
      }

      function resetIntegrationResult(card) {
        const { container, players, assignments, updateBtn, saveBtn } = getIntegrationResultElements(card);
        if (!container) return;
        container.hidden = true;
        if (players) {
          players.textContent = '';
        }
        if (assignments) {
          assignments.innerHTML = '';
        }
        if (updateBtn) {
          updateBtn.disabled = true;
        }
        if (saveBtn) {
          saveBtn.disabled = true;
        }
      }

      function formatListPreview(values = [], max = 6) {
        const unique = dedupeNames(values);
        if (!unique.length) {
          return '';
        }
        const shown = unique.slice(0, max);
        let preview = shown.join(', ');
        if (unique.length > shown.length) {
          preview += ` ‚Ä¶ (+${unique.length - shown.length} more)`;
        }
        return preview;
      }

      function countAssignments(assignments = []) {
        return assignments.reduce((total, entry) => {
          if (!entry || typeof entry !== 'object') return total;
          const items = Array.isArray(entry.items) ? entry.items.length : 0;
          return total + items;
        }, 0);
      }

      function renderAssignmentDetails(container, assignments = []) {
        if (!container) return;
        container.innerHTML = '';
        const meaningful = assignments.filter((entry) => entry && Array.isArray(entry.items) && entry.items.length);
        const total = countAssignments(assignments);
        const teammateCount = meaningful.length;
        const summary = document.createElement('p');
        if (!total) {
          summary.textContent = 'No assigned work found for this selection.';
          container.appendChild(summary);
          return;
        }
        summary.textContent = `Loaded ${total} assignment${total === 1 ? '' : 's'} for ${teammateCount} teammate${teammateCount === 1 ? '' : 's'}.`;
        container.appendChild(summary);
        const list = document.createElement('ul');
        meaningful.slice(0, 5).forEach((entry) => {
          const li = document.createElement('li');
          const playerName = entry.player || 'Unnamed teammate';
          const examples = Array.isArray(entry.items)
            ? entry.items
                .map((item) => item.summary || item.title || item.name || item.key || item.number || item.id)
                .filter(Boolean)
            : [];
          if (examples.length) {
            const sample = examples.slice(0, 2).join('; ');
            li.textContent = `${playerName} ‚Äì ${sample}${examples.length > 2 ? '‚Ä¶' : ''}`;
          } else {
            const count = Array.isArray(entry.items) ? entry.items.length : 0;
            li.textContent = `${playerName} ‚Äì ${count} item${count === 1 ? '' : 's'}`;
          }
          list.appendChild(li);
        });
        if (meaningful.length > 5) {
          const remaining = meaningful.length - 5;
          const li = document.createElement('li');
          li.textContent = `‚Ä¶and ${remaining} more teammate${remaining === 1 ? '' : 's'}`;
          list.appendChild(li);
        }
        container.appendChild(list);
      }

      function updateIntegrationResult(card, service, data, includeAssignments) {
        const { container, players, assignments, updateBtn, saveBtn } = getIntegrationResultElements(card);
        if (!container) return;
        const playersList = Array.isArray(data?.players) ? dedupeNames(data.players) : [];
        if (players) {
          if (playersList.length) {
            const preview = formatListPreview(playersList, 6);
            players.textContent = `${playersList.length} teammate${playersList.length === 1 ? '' : 's'} ready to import${preview ? `: ${preview}` : ''}.`;
          } else {
            players.textContent = 'No players detected from the latest test.';
          }
        }

        if (assignments) {
          assignments.innerHTML = '';
          if (includeAssignments) {
            const assignmentData = Array.isArray(data?.assignments) ? data.assignments : [];
            renderAssignmentDetails(assignments, assignmentData);
          } else {
            const note = document.createElement('p');
            note.textContent = 'Assignments were not requested. Turn on ‚ÄúInclude assigned work when testing‚Äù and try again to preview cards or issues.';
            assignments.appendChild(note);
          }
        }

        if (updateBtn) {
          updateBtn.disabled = !playersList.length;
        }
        if (saveBtn) {
          if (!includeAssignments) {
            saveBtn.disabled = true;
          } else {
            const totalAssignments = countAssignments(Array.isArray(data?.assignments) ? data.assignments : []);
            saveBtn.disabled = totalAssignments === 0;
          }
        }

        container.hidden = false;
      }
      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        return date.toLocaleString();
      }

      async function refreshIntegrationCards() {
        if (!integrationCards.length) return;
        try {
          const response = await fetch(integrationEndpoint, {
            method: 'GET',
            headers: { 'X-Integration-Client': integrationClientId },
          });
          if (!response.ok) {
            throw new Error('Failed to load integration settings');
          }
          const data = await response.json();
          integrationCards.forEach((card) => {
            const service = card.dataset.service;
            const info = data?.services?.[service];
            const enabledInput = card.querySelector('.integration-enabled');
            const resourceInput = card.querySelector('.integration-resource');
            const tokenInput = card.querySelector('.integration-token');
            const includeAssignmentsInput = card.querySelector('.integration-include-assignments');
            const tokenPreview = card.querySelector('.integration-token-preview');
            const disconnectBtn = card.querySelector('.integration-disconnect');
            const fieldInputs = card.querySelectorAll('[data-field]');

            if (enabledInput) enabledInput.checked = Boolean(info?.enabled);
            if (resourceInput) resourceInput.value = info?.resource ?? '';
            if (tokenInput) tokenInput.value = '';
            if (includeAssignmentsInput) includeAssignmentsInput.checked = Boolean(info?.includeAssignments);
            fieldInputs.forEach((input) => {
              const key = input.dataset.field;
              if (!key) return;
              input.value = info?.fields?.[key] ?? '';
            });
            if (tokenPreview) {
              if (info?.hasToken) {
                const preview = info.tokenPreview || '‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                const updated = formatTimestamp(info.lastUpdated);
                tokenPreview.textContent = `Token saved (${preview})${updated ? ` ‚Äì updated ${updated}` : ''}.`;
              } else {
                tokenPreview.textContent = 'No token stored yet.';
              }
            }
            if (disconnectBtn) {
              disconnectBtn.disabled = !(info?.hasToken || info?.enabled);
            }
            integrationResults.delete(service);
            resetIntegrationResult(card);
            setIntegrationStatus(card, '');
          });
        } catch (error) {
          console.error('Integration load error', error);
          integrationCards.forEach((card) => {
            setIntegrationStatus(card, 'Unable to load integration settings.', 'error');
          });
        }
    }

      async function handleSaveIntegration(card, service) {
        const enabledInput = card.querySelector('.integration-enabled');
        const resourceInput = card.querySelector('.integration-resource');
        const tokenInput = card.querySelector('.integration-token');
        const includeAssignmentsInput = card.querySelector('.integration-include-assignments');
        const fieldInputs = card.querySelectorAll('[data-field]');

        const payload = {
          enabled: enabledInput?.checked ?? false,
          resource: resourceInput?.value?.trim() ?? '',
          includeAssignments: includeAssignmentsInput?.checked ?? false,
        };

        if (fieldInputs.length) {
          payload.fields = {};
          fieldInputs.forEach((input) => {
            const key = input.dataset.field;
            if (!key) return;
            payload.fields[key] = input.value?.trim() ?? '';
          });
        }

        const tokenValue = tokenInput?.value?.trim();
        if (tokenValue) {
          payload.token = tokenValue;
        }

        try {
          setIntegrationBusy(card, true);
          setIntegrationStatus(card, 'Saving connection‚Ä¶');
          const response = await fetch(`${integrationEndpoint}/${service}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'X-Integration-Client': integrationClientId,
            },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            const errorBody = await response.json().catch(() => ({}));
            const message = errorBody?.error || 'Unable to save connection.';
            throw new Error(message);
          }
          setIntegrationStatus(card, 'Connection saved.', 'success');
          if (tokenInput) {
            tokenInput.value = '';
          }
          integrationResults.delete(service);
          resetIntegrationResult(card);
          await refreshIntegrationCards();
          if (!payload.enabled) {
            clearAssignmentSnapshot(service);
          }
        } catch (error) {
          console.error(`Integration save error for ${service}`, error);
          setIntegrationStatus(card, error.message || 'Failed to save connection.', 'error');
        } finally {
          setIntegrationBusy(card, false);
        }
      }

      async function handleDisconnectIntegration(card, service) {
        try {
          setIntegrationBusy(card, true);
          setIntegrationStatus(card, 'Disconnecting‚Ä¶');
          const response = await fetch(`${integrationEndpoint}/${service}`, {
            method: 'DELETE',
            headers: { 'X-Integration-Client': integrationClientId },
          });
          if (!response.ok) {
            const errorBody = await response.json().catch(() => ({}));
            const message = errorBody?.error || 'Unable to disconnect.';
            throw new Error(message);
          }
          setIntegrationStatus(card, 'Connection removed.', 'success');
          integrationResults.delete(service);
          resetIntegrationResult(card);
          await refreshIntegrationCards();
          clearAssignmentSnapshot(service);
        } catch (error) {
          console.error(`Integration disconnect error for ${service}`, error);
          setIntegrationStatus(card, error.message || 'Failed to disconnect.', 'error');
        } finally {
          setIntegrationBusy(card, false);
        }
      }

      function summarizeIntegrationResult(service, data, includeAssignments = false) {
        if (!data || typeof data !== 'object') {
          return 'Connection test succeeded.';
        }

        const serviceName = formatServiceName(service);
        const playerCount = Array.isArray(data.players) ? data.players.length : 0;
        let assignmentCount = 0;

        if (Array.isArray(data.assignments)) {
          assignmentCount = countAssignments(data.assignments);
        } else if (Array.isArray(data.issues)) {
          assignmentCount = data.issues.length;
        } else if (Array.isArray(data.cards)) {
          assignmentCount = data.cards.length;
        } else if (typeof data.count === 'number') {
          assignmentCount = data.count;
        } else if (typeof data.assignmentCount === 'number') {
          assignmentCount = data.assignmentCount;
        }

        const parts = [`${serviceName} connection OK.`];
        if (playerCount) {
          parts.push(`Found ${playerCount} participant${playerCount === 1 ? '' : 's'}.`);
        }
        if (includeAssignments) {
          if (assignmentCount) {
            parts.push(`Loaded ${assignmentCount} assignment${assignmentCount === 1 ? '' : 's'}.`);
          } else {
            parts.push('No assigned work found to store.');
          }
        }

        return parts.join(' ');
      }

      async function handleTestIntegration(card, service) {
        try {
          setIntegrationBusy(card, true);
          setIntegrationStatus(card, 'Checking connection‚Ä¶');
          integrationResults.delete(service);
          resetIntegrationResult(card);
          const includeAssignmentsInput = card.querySelector('.integration-include-assignments');
          const includeAssignments = includeAssignmentsInput?.checked ?? false;
          const response = await fetch(`/api/integrations/${service}/pull`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Integration-Client': integrationClientId,
            },
            body: JSON.stringify({ includeAssignments }),
          });

          const body = await response.json().catch(() => ({}));
          if (!response.ok) {
            const message = body?.error || 'Unable to reach integration service.';
            throw new Error(message);
          }

          const data = body?.data || {};
          integrationResults.set(service, { data, includeAssignments });
          updateIntegrationResult(card, service, data, includeAssignments);
          const summary = summarizeIntegrationResult(service, data, includeAssignments);
          setIntegrationStatus(card, `${summary} Review the fetched data below and choose what to do.`, 'success');
        } catch (error) {
          console.error(`Integration test error for ${service}`, error);
          integrationResults.delete(service);
          resetIntegrationResult(card);
          setIntegrationStatus(card, error.message || 'Connection test failed.', 'error');
        } finally {
          setIntegrationBusy(card, false);
        }
      }

      function handleIntegrationPlayersAction(card, service) {
        const record = integrationResults.get(service);
        const players = record?.data?.players;
        if (!Array.isArray(players) || !players.length) {
          setIntegrationStatus(card, 'Run Test Connection to load players first.', 'error');
          return;
        }
        if (applyPlayersFromIntegration(service, players)) {
          setIntegrationStatus(card, `Player List updated with ${players.length} teammate${players.length === 1 ? '' : 's'}.`, 'success');
        } else {
          setIntegrationStatus(card, 'No new teammates were added this time.', 'info');
        }
      }

      function handleIntegrationAssignmentsAction(card, service) {
        const record = integrationResults.get(service);
        if (!record || !record.includeAssignments) {
          setIntegrationStatus(card, 'Run Test Connection with ‚ÄúInclude assigned work‚Äù enabled first.', 'error');
          return;
        }
        const assignments = Array.isArray(record.data?.assignments) ? record.data.assignments : [];
        if (!persistAssignmentsSnapshot(service, record.data)) {
          setIntegrationStatus(card, 'No assigned work available to save yet.', 'error');
          return;
        }
        const totalAssignments = countAssignments(assignments);
        setIntegrationStatus(card, `Saved ${totalAssignments} assignment${totalAssignments === 1 ? '' : 's'} for later use.`, 'success');
      }

      savePlayersBtn?.addEventListener('click', savePlayers);
      resetPlayersBtn?.addEventListener('click', resetPlayers);

      Object.values(brandInputs).forEach((input) => {
        input?.addEventListener('input', () => {
          const data = collectBrandForm(true);
          updatePreview(data);
        });
      });

      themeModeInput?.addEventListener('change', () => {
        if (themeModeInput.value !== 'manual' && themeSelectInput) {
          themeSelectInput.value = 'default';
        }
        setManualThemeVisibility(
          themeModeInput.value,
          seasonalThemesToggle ? seasonalThemesToggle.checked : true,
        );
        updatePreview(collectBrandForm(true));
      });

      seasonalThemesToggle?.addEventListener('change', () => {
        setManualThemeVisibility(
          themeModeInput ? themeModeInput.value : DEFAULT_BRAND.themeMode,
          seasonalThemesToggle.checked,
        );
        updatePreview(collectBrandForm(true));
      });

      themeSelectInput?.addEventListener('change', () => {
        updatePreview(collectBrandForm(true));
      });

      saveBrandBtn?.addEventListener('click', saveBrand);
      resetBrandBtn?.addEventListener('click', resetBrand);

      if (integrationNavButtons.length && integrationCards.length) {
        const initialService =
          integrationNavButtons.find((button) => button.classList.contains('is-active'))?.dataset.integrationTarget ||
          integrationCards[0]?.dataset.service;
        setActiveIntegration(initialService);
        integrationNavButtons.forEach((button) => {
          button.addEventListener('click', () => {
            setActiveIntegration(button.dataset.integrationTarget);
          });
        });
      }

      integrationCards.forEach((card) => {
        const service = card.dataset.service;
        const saveBtn = card.querySelector('.integration-save');
        const disconnectBtn = card.querySelector('.integration-disconnect');
        const testBtn = card.querySelector('.integration-test');
        const updateAction = card.querySelector('.integration-action-update');
        const saveAction = card.querySelector('.integration-action-save');
        const changeInputs = card.querySelectorAll('.integration-enabled, .integration-include-assignments');
        const tokenHelper = card.querySelector('.trello-token-helper');

        saveBtn?.addEventListener('click', () => handleSaveIntegration(card, service));
        disconnectBtn?.addEventListener('click', () => handleDisconnectIntegration(card, service));
        testBtn?.addEventListener('click', () => handleTestIntegration(card, service));
        updateAction?.addEventListener('click', () => handleIntegrationPlayersAction(card, service));
        saveAction?.addEventListener('click', () => handleIntegrationAssignmentsAction(card, service));
        if (service === 'trello') {
          tokenHelper?.addEventListener('click', () => openTrelloTokenGenerator(card));
        }
        changeInputs.forEach((input) => {
          input?.addEventListener('change', () => {
            integrationResults.delete(service);
            resetIntegrationResult(card);
            setIntegrationStatus(card, '');
          });
        });
      });

      startTourBtn?.addEventListener('click', openTour);
      tourPrevBtn?.addEventListener('click', () => {
        if (currentTourStep > 0) {
          goToTourStep(currentTourStep - 1);
        }
      });
      tourNextBtn?.addEventListener('click', () => {
        if (!TOUR_STEPS.length) return;
        if (currentTourStep === TOUR_STEPS.length - 1) {
          closeTour();
          return;
        }
        goToTourStep(currentTourStep + 1);
      });
      tourCloseBtn?.addEventListener('click', closeTour);
      tourOverlay?.addEventListener('click', (event) => {
        if (event.target === tourOverlay) {
          closeTour();
        }
      });

      window.addEventListener('resize', refreshTourLayout);
      window.addEventListener('scroll', refreshTourLayout, { passive: true });
      document.addEventListener('keydown', (event) => {
        if (!tourActive) return;
        if (event.key === 'Escape') {
          event.preventDefault();
          closeTour();
          return;
        }
        if (event.key === 'ArrowRight') {
          event.preventDefault();
          if (currentTourStep === TOUR_STEPS.length - 1) {
            closeTour();
          } else {
            goToTourStep(currentTourStep + 1);
          }
        } else if (event.key === 'ArrowLeft') {
          event.preventDefault();
          goToTourStep(currentTourStep - 1);
        }
      });

      loadPlayers();
      loadBrand();
      refreshIntegrationCards();
    });
  </script>
</body>

</html>
